---
title: "데이터분석을위한프로그래밍언어 Assignment 3"
author: "2018170837 이요환"
date: 2019-11-09
output: html_notebook
---

Assignment 3 RMD 제출물입니다.


## Data Preparation

**[1] Load the dataset using read.csv( ) functions**

```{r}
house_data <- read.csv("kc_house_data.csv")
```

같은 경로에 있기 때문에 파일의 경로를 모두 입력하지 않고 파일명 만을 입력해 house_data 변수에 할당했다.  


***

**[2] Create a bar plot with regard to the number of bedrooms**

```{r}
barplot(house_data$bedrooms)
hist(house_data$bedrooms)
```
barplot 함수에 house_data dataframe의 bedrooms 열을 입력해 bedrooms의 개수에 대한 막대 그래프가 출력되도록 했다.

***

**[3] Remove the rows (1) without rooms (number of rooms =1) or (2) with rooms more than 6 (number of rooms > 6)**
```{r}

for (i in c(1:nrow(house_data))) {
  continue <- TRUE
  while (continue == TRUE) {
    if (house_data$bedrooms[i] + house_data$bathrooms[i] == 0 | house_data$bedrooms[i] + house_data$bathrooms[i] > 6) {
      house_data <- house_data[-i,]}
    else {continue <- FALSE}
    
  }
}

```

for문의 범위를 c(1:nrow(house_data))로 해서 모든 행에 대해 조건을 만족 시키는 지 검사할 수 있도록 했다.  
이 때, 단순히 이 작업만을 반복하면 조건을 만족시켰을 떄(방의 수가 1개이거나 6개 이상일 때) 그 행이 삭제되고 i는 다시 1만큼 커진 후 검사되므로, 삭제된 행 직후의 행을 검사하지 못한다. 따라서 while문을 이용해 조건을 연속적으로 만족시키는 경우를 모두 검사할 수 있도록 했다.
```{r}
A1 <- house_data[house_data$bedrooms + house_data$bathrooms > 0 & house_data$bedrooms + house_data$bathrooms <=6,]
```
조건을 만족시키는 index를 바로 불러와 변수에 할당시킴으로써 더 간단한 방법으로도 해결할 수 있다.



***
  
**[4] Randomly sample 5,000 rows for computational efficiency**
```{r}
index_sample <- sample(nrow(house_data), size = 5000, replace = FALSE)
house_sample <- house_data[index_sample, ]
head(house_sample)
```
sample 함수를 이용해 house_data의 행의 번호를 무작위로 뽑은 뒤, (5000개, 비복원추출) house_data에 인덱싱해서 각각 의 로우들을 house_sample 이라는 변수에 할당시켜 house_data의 5000개 표본으로 된 dataframe을 만들었다.











## Plotting and Interpretation

**[1] Create at least 10 different plots and interpret the results to understand the dataset itself.**
**Visit the recommended reference sites to see what types of graphs can be generated by "ggplot?? package. Googling is strongly recommended to create your own plots.**


1.  
![](https://ifh.cc/g/cgbGj.png)
```{r}
ggplot(house_sample, aes(floors, bathrooms)) + geom_jitter(aes(color=price), size = 0.5) + labs(title = 'Realation Between Floors and Bathrooms', subtitle = 'Jitter Plot')
```
floors와 bathrooms(discrete한 데이터)에 대한 산포도를 그려봤다.  둘 다 discrete한 데이터이므로 겹치는 부분이 많이 나타나서 이를 더 보기 쉽게 하기 위해 geom_point가 아닌 geom_jitter plot을 이용했다. size는 0.5로 설정했다.  
각각에 대응되는 가구의ㅣ 수와 error의 정도를 알 수 있었다. 또 floors가 1, 2일 때를 각각 비교해보면, 1층일 때는 욕실이 1~2개가 가장 많고, 2층일 때는 2.5개 일때가 가장 많다는 것을 알 수 있었다.  
floors에 대해 boxplot이나 violin plot을 이용했어도 더 잘 확인할 수 있었을 것이다.

***

2.  
![]()https://ifh.cc/g/RijXK.png
```{r}
install.packages('ggExtra')
library(ggExtra)

p <- ggplot(house_sample, aes(price, sqft_living)) + geom_jitter(aes(color= factor(grade))) + geom_smooth(se=F) + labs(title = 'Relation Between Price and square feet of living space', subtitle = 'scatter plot & smooth plot', caption = 'Except standard error', y='Square Feet of living space')

ggMarginal(p, type='histogram', fill = 'transparent')
```
price와 sqft_living의 관계를 알 기 위해 산포도와 smooth plot을 그렸다. 또한 point의 색을 grade로 설정해 grade와 price, sqft_living과의 관계를 시각적으로 볼 수 있게 하고 싶었다.  
전체적으로 가격과 거실의 평수가 어느 곳에 많이 밀집되어있는 지를 확인하고 싶어서  ggExtra package의 ggMargianl함수를 이용해 그래프의 바깥쪽에 histogram을 그렸다.  
price와 sqft_living은 어느 정도 비례하는 경향이 있으며 각각 약 200,000 ~ 800,000, 700 ~ 3,000에 많이 분포한다는 사실을 알 수 있었다.

***


3.  
![](https://ifh.cc/g/NFMv7.png)
```{r}
g3 <-  ggplot(data=house_sample, aes(x=sqft_living15, y=sqft_living)) + geom_density2d(aes(color=floors)) +  geom_point(size = 0, alpha=0.05) + facet_wrap(~floors) + labs(title = 'Relation of sqft of living space with adjacent house', subtitle = 'density2 plot',  y='Square Feet of living space')
g3

```
sqft_living15와 sqft_living의 관계를 확인하기 위해 density 분포를 그렸다. 또한 이 두 요소가 층수와도 관련이 있을 것이라 생각해서 facet_wrap 함수를 이용해 층수 별로 그려지도록 했다. 또 x축의 글씨가 겹쳐 보기 힘들었고 이를 해결하기 위해 theme 함수의 axis.text.x=element_text() 인자를 이용해 각도를 90도로 회전시켰다.  
층수가 2, 2.5층일 때 living, living15의 평수가 층수가 다른 경우에 비해 크게 나타났고, 전체적으로 두 값이 비슷하게 나타났다. 


4.  
![](https://ifh.cc/g/rgf61.png)
```{r}
house_sample$floors <- as.character(house_sample$floors)

ggplot(house_sample, aes(floors, yr_built)) + geom_point(size=0.5, position = 'jitter') + geom_violin(scale='width', aes(color= floors)) + labs(title='Relation Between Number of Floors and Year built', subtitle='violin plot & point plot')

```
floors와 yr_built의 관계를 나타낸 산포도와 violin 그래프이다. numeric 형태인 floors로는 각각의 경우에 따른 violin 그래프를 그릴 수 없기 때문에 as.character() 함수를 이용해 floors column을 모두 character로 바꿔준 뒤, x축에 대입했다. violin 그래프의 두께로 년도별로 몇 층의 건물이 많이 지어졌는 지 알 수 있었다.
또한 floors가 discrete한 데이터이므로 점 분포를 보기 쉽게 하기 위해 position='jitter', size = 0.5로 설정해 점이 더 작고 흩뿌려진 모습으로 나타나도록 했다. 또 violin 그래프는 floors 별로 색을 다르게 칠해 보기 쉽도록 했다.
그래프를 통해 1950년 ~ 1980년 즈음엔 1층 건물이, 1900년 ~ 1935년 즈음엔 1.5층이, 1975년 ~ 2000년대 즈음엔 2층 이상의 건물이 많이 지어지는 trends가 존재했다는 사실을 알 수 있었다.


***



***

5.  
![](https://ifh.cc/g/SgpMN.png)
```{r}

house_sample$grade <- as.numeric(house_sample$grade)


ggplot(data = house_sample, aes(x=sqft_living)) + geom_density(aes(fill=factor(grade)), alpha =0.6) + labs(subtitle='Density plot', title='Sqft of Living Grouped by Grade', fill='Grade')
```
density plot을 이용해 주거 공간의 평수의 분포를 grade 별로 나타냈다. 밀도함수의 색을 grade로 나타내 각각 분포를 비교하게 쉽게 했다. 또 그래프가 겹치는 부분도 보기 쉽게 하기 위해 alpha로 투명도를 조절했다.  
grade와 sqft_living가 비례할 것이라고 생각했고, 어느정도 그렇다는 사실을 그래프를 통해 알 수 있다. 특히 Grade가 매우 높거나 낮은 경우에는 grade가 중간에 가까운 경우에 비해 분포의 편차가 작게 나타났다.



6.  
![](https://ifh.cc/g/GZgk7.png)
```{r}
house_sample$grade <- as.character(house_sample$grade)

ggplot(data = house_sample) + geom_point(aes(x=grade, y=price, color = grade), alpha = 0.1, position = 'jitter') + geom_boxplot(mapping = aes(x = grade, y = price, color = grade)) + scale_x_discrete(limits=c('1','2','3','4','5','6','7','8','9','10','11','12')) + labs(subtitle='point plot and box plot', title='Relation Between Grade and Price', fill='Grade')

```
  boxplot과 point plot을 동시에 그려 grade에 따른 price의 분포를 확인할 수 있는 그래프를 만들었다.  
  grade가 discrete한 형태가 아니므로 boxplot을 이용할 수 없어서 grade의 원소를 모두 character로 바꿔주었다.  
  character가 되면 숫자 오름차순으로 자동 정렬되지 않기 때문에 scale_x_discrete 함수를 이용해서 오름차순으로 정렬했다. 또 point plot의 투명도를 높여 box plot과 함께 보기 쉽도록 했고, 색을 grade 별로 다르게 해 그래프가 한 눈에 들어오도록 했다.  
  point plot의 position을 'jitter'로 설정해 점이 겹쳐져 그 양을 확인할 수 없는 점을 해결했다. 하지만 box plot의 위에 그려져서 몇 개의 box plot이 가려지는 문제가 생겼다. 이는 plot을 추가하는 순서를 바꿈으로써 해결할 수 있었다. 
  그래프를 통해 grade가 높을수록 price가 높아진다는 사실을 알 수 있었다. 또 boxplot의 모양을 보면 grade가 높아질 수록 가격의 편차도 어느정도 증가하는 모습을 보인다.  





***

7.  
![](https://ifh.cc/g/foxFB.png)
```{r}
ggplot(data=house_sample, aes(grade)) + geom_bar(aes(fill = condition))+ facet_wrap(~condition, nrow = 2) + scale_x_discrete(limits=c('1','2','3','4','5','6','7','8','9','10','11','12')) + labs(subtitle='Bar plot', title='Grade Bar Plot Grouped by Conditions')

```

8.  
![](https://ifh.cc/g/xTggl.png)
```{r}
house_sample$grade <- as.character(house_sample$grade)

ggplot(data=house_sample, aes(grade)) + geom_bar(aes(fill = condition)) + scale_x_discrete(limits=c('1','2','3','4','5','6','7','8','9','10','11','12')) + labs(subtitle='Bar plot', title='Engaged Grade Histogram')
```
  각 grade 별로 condition의 비율을 알고자 bar plot을 이용해 그래프를 그렸다. fill = condition으로 지정해 색으로 구분을 하도록 했고, 위 그래프는 이를 condition 기준으로 나눈 것이다.  
  as.character 함수로 grade가 discrete한 character의 형태가 되었으므로, scale_x_discrete함수를 이용해 차례대로 정렬해주었다.  
  위 그래프를 통해 대부분의 가구가 6~8 grade에 속해있다는 사실을 알 수 있었지만, 원소의 차이가 grade마다 크게 차이가 나서 그 비율을 알기 쉽지 않았다.  
9.  
![](https://ifh.cc/g/fFfC2.png)
```{r}
pie <- ggplot(house_sample, aes(x = factor(1), fill = factor(condition))) + 
  geom_bar(width = 1, position = 'fill') +
  theme(axis.line = element_blank(), 
        plot.title = element_text(hjust=0.5)) + 
  labs(fill="condition", 
       x=NULL, 
       y=NULL, 
       title="Pie Chart of Grade Grouped by Condition", 
       caption="") + facet_wrap(~grade, nrow = 2)
  
pie + coord_polar(theta = "y", start=0)

```
따라서 bar plot을 둥글게 돌려놓은 형태인 Pie chart를 같은 조건으로 그렸다. coord_polar 함수를 이용했다. position = 'fill'로 설정해 grade별 원소의 수에 영향을 받지 않고 그 비율을 알 수 있었다. 하지만 grade와 condition의 상관관계는 뚜렷하지 않은 것으로 보였다.

***

10.  
![](https://ifh.cc/g/acSK6.png)
```{r}
ggplot(house_sample, aes(sqft_above, sqft_basement)) + geom_count(aes(alpha=0.2, color = ..n..)) + ylim(c(1,1700)) + labs(subtitle = 'count plot', title="Relation Between sqft of above and basement", caption="Y limits = 1 ~ 1700")
```
  집 지상의 넓이와 지하의 넓이 사이의 관계와 밀집한 정도를 확인하고자 count plot을 그렸다. 겹치는 부분을 보기 쉽게 하기위해 alpha=0.2로 설정했고 점의 크기와 더불어 색을 설정해 많이 밀집된 부분에 더 확연한 차이를 두고자 했다.  또, 지하실이 없는 가구를 제외하기 위해 ylim함수를 이용해 y의 범위를 제한했다.
  전체적으로 지상과 지하의 넓이는 큰 차이가 없는 것으로 보이지만, 약 x=500, y=750부터 y=x의 형태로 점선이 그려지는 경향이 보인다.  
  
  ***
  
11.  
![](https://ifh.cc/g/721Et.png)
```{r}
ggplot(data=house_sample) + geom_histogram(aes(x=price, fill = factor(bedrooms))) + labs(title = 'Histogram: Number of house per price', subtitle = 'Histogram Plot', fill='# Bedrooms')
```
가격대 별로 가구들이 어떻게 분포되어 있는지 확인하기 위해 히스토그램을 그렸다. 침실의 개수 역시 가격의 영향을 받을 것이라 생각해 color을 Bedrooms로 지정해 한번에 확인할 수 있도록 했다. 
  price가 약 230,000~700,000에 많이 분포해 있고, price가 높아질 수록 노란색, 초록색 (# of bedrooms = 1, 2)의 비율이 줄어드는 것으로 보아, Bedrooms와 price는 비례하는 경향이 있다고 볼 수 있다.

***

```{r}
install.packages('gganimate')
install.packages('gapminder')
install.packages('gifski_renderer')
library(gifski_renderer)
library(gganimate)
library(gapminder)

g <- ggplot(gapminder, aes(x=sqft_living, y=price)) + geom_point() + facet_wrap(~grade) + scale_x_log10() + labs(title = ' Yr_built: {frame_time}', x= 'Price', y='Sqft_living') + transition_manual(yr_built) + ease_aes('linear')
g
gganimate(g, interval = 0.2)
```

***

**[2] Establish at least 5 hypotheses about the price **
(ex: The number of rooms is positively related to the price. In other words, houses with more rooms are generally more expensive
than houses with fewer rooms)

1. 전체 부지의 평수보다 주거공간의 평수가 가격에 더 큰 영향을 미칠 것이다.
2. grade가 같으면, condition이 높을 수록 가격이 높을 것이다.
3. 물가에 있는 집이 그렇지 않은 집보다 가격이 높을 것이다.
4. 집이 거래된 날짜가 클수록 가격이 높을 것이다. (물가 상승등의 이유로)
5. 오래된 집일수록 가격이 낮을 것이다. (renovate된 집은 제외)

***

**[3] Create appropriate plots to qualitatively (not quantitatively based on the hypothesis testing method generally used in statistics) verify each hypothesis and determine whether each hypothesis can be accepted based on the generated plot.**

1.전체 부지의 평수보다 주거공간의 평수가 가격에 더 큰 영향을 미칠 것이다.  
![](https://ifh.cc/g/yGNm9.png)
```{r}
ggplot(house_sample, aes(x=sqft_lot, y=price)) + geom_smooth()
```
![](https://ifh.cc/g/rm8BH.png)
```{r}
ggplot(house_sample, aes(x=sqft_living, y=price)) + geom_smooth() 


```
데이터 분포를 선의 형태로 추청해주는 smooth 그래프를 그려봤을 때, sqft_living과 sqft_lot이 증가함에 따라 증가하는 price가 sqft_living의 경우 훨씬 가파르므로, 주거공간의 평수가 전체 부지의 평수보다 큰 영향을 미친다고 할 수 있다.  

***

2. condition이 같으면 grade가 높을수록 가격이 높을 것이다.  
![](https://ifh.cc/g/l97Hx.png)
```{r}
house_sample$condition <- as.character(house_sample$condition)
house_sample$grade <- as.numeric(house_sample$grade)
ggplot(data = house_sample, mapping = aes(x=price, y=grade, color=condition)) + geom_smooth(se = F)
```
condition을 character 형태로 바꾼 뒤 각각 condition 별로 price에 대한 grade의 smooth 그래프를 그렸다. condition이 같은 상황에서 모든 그래프가 상승하는 형태이므로, condition의 영향이 없을 때 grade가 높을수록 price가 높다는 것을 알 수 있다.

***

3.물가 주변에 있는 집이 그렇지 않은 집보다 가격이 높을 것이다.  
![](https://ifh.cc/g/8cAFT.png)
```{r}
ggplot(house_sample) + geom_boxplot(aes(x=factor(waterfront), y= price, color=factor(waterfront))) + labs(title='waterfront vs price', x='waterfront', fill = 'waterfront')
```
discrete한 형태인 waterfront를 비교하기 쉬운 box plot(중앙값, 상위 25, 75% 등의 정보를 알기 쉽다.)을 그려 비교해 봤다. 물가에 있지 않은 집의 가격 상위 25%가 물가에 있는 집의 가격 하휘 75%가 비슷할 정도로 가격 차이가 많이 난다는 사실을 알 수 있다. 따라서 평균적으로 물가에 있는 집의 가격이 그렇지 않은 집의 가격보다 높다고 할 수 있다.

***

4.  
![](https://ifh.cc/g/Z3hmc.png)
```{r}

date_vec <- c()

for (i in c(1:5000)) {
  date_vec <- c(date_vec, substr(house_sample$date[i], 1, 6))
}

house_sample$date <- date_vec
house_sample$date <- as.character(house_sample$date)

ggplot(house_sample, aes(x=date, y=price)) + geom_violin(aes(fill=date)) + ylim(c(0,900000)) + theme(axis.text.x=element_text(angle=90))
```
date cloumn의 각각의 원소들을 1~6번째 character만 남겨 년과 월만을 데이터로 남겼다. 그 후 남은 데이터를 character로 바꿔 각각의 월에 대한 price의 분포를 violin을 통해 나타냈다. 또한 가격이 매우 큰 적은 표본에 의해 그래프를 보기 힘든 문제를 해결하기 위해 y의 최대값을 900000으로 설정했다.  

각각의 월에 따라 그래프의 형태가 크게 변화하지 않으므로, 가격이 증가하지 않았다는 사실을 알 수 있다. 따라서 집이 거래된 날짜가 최근일수록 가격이 높다는 가설은 틀렸다고 볼 수 있다.

***

5.  
![](https://ifh.cc/g/ztcgn.png)
```{r}
house_sample <- house_sample[house_sample$yr_renovated == 0, ]

ggplot(house_sample, aes(x=yr_built, y= price)) +geom_hex() 
```
renovated 된 경우르 제외하기 위해 house_sample에서 yr_renovated가 0인 경우만을 남겼다. 그 후 색의 차이를 통해 빈도를 알 수 있는 geom_hex plot을 이용해 지어진 년도 대비 가격을 알 수 있는 그래프를 그렸다.  
yr_built가 커짐에 따라 빈도수가 높아지지만, price의 상승은 미미하다. 즉, 지어진 년도가 가격에 영향을 미치지 않는다는 사실을 알 수 있다. 


